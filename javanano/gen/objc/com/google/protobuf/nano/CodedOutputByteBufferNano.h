//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/marcussmith/Laundryman/Libraries/protobuf/javanano/src/main/java/com/google/protobuf/nano/CodedOutputByteBufferNano.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleProtobufNanoCodedOutputByteBufferNano")
#ifdef RESTRICT_ComGoogleProtobufNanoCodedOutputByteBufferNano
#define INCLUDE_ALL_ComGoogleProtobufNanoCodedOutputByteBufferNano 0
#else
#define INCLUDE_ALL_ComGoogleProtobufNanoCodedOutputByteBufferNano 1
#endif
#undef RESTRICT_ComGoogleProtobufNanoCodedOutputByteBufferNano

#if !defined (ComGoogleProtobufNanoCodedOutputByteBufferNano_) && (INCLUDE_ALL_ComGoogleProtobufNanoCodedOutputByteBufferNano || defined(INCLUDE_ComGoogleProtobufNanoCodedOutputByteBufferNano))
#define ComGoogleProtobufNanoCodedOutputByteBufferNano_

@class ComGoogleProtobufNanoMessageNano;
@class IOSByteArray;

/*!
 @brief Encodes and writes protocol message fields.
 <p>This class contains two kinds of methods:  methods that write specific
  protocol message constructs and field types (e.g. <code>writeTag</code> and 
 <code>writeInt32</code>) and methods that write low-level values (e.g. 
 <code>writeRawVarint32</code> and <code>writeRawBytes</code>).  If you are
  writing encoded protocol messages, you should use the former methods, but if
  you are writing some other format of your own design, use the latter. 
 <p>This class is totally unsynchronized.
 @author kneton@@google.com Kenton Varda
 */
@interface ComGoogleProtobufNanoCodedOutputByteBufferNano : NSObject

#pragma mark Public

/*!
 @brief Verifies that <code>spaceLeft()</code> returns zero.It's common to create
  a byte array that is exactly big enough to hold a message, then write to
  it with a <code>CodedOutputStream</code>.
 Calling <code>checkNoSpaceLeft()</code>
  after writing verifies that the message was actually as big as expected,
  which can help catch bugs.
 */
- (void)checkNoSpaceLeft;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>bool</code> field, including tag.
 */
+ (jint)computeBoolSizeWithInt:(jint)fieldNumber
                   withBoolean:(jboolean)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>bool</code> field.
 */
+ (jint)computeBoolSizeNoTagWithBoolean:(jboolean)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>bytes</code> field, including tag.
 */
+ (jint)computeBytesSizeWithInt:(jint)fieldNumber
                  withByteArray:(IOSByteArray *)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>bytes</code> field.
 */
+ (jint)computeBytesSizeNoTagWithByteArray:(IOSByteArray *)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>double</code> field, including tag.
 */
+ (jint)computeDoubleSizeWithInt:(jint)fieldNumber
                      withDouble:(jdouble)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>double</code> field, including tag.
 */
+ (jint)computeDoubleSizeNoTagWithDouble:(jdouble)value;

/*!
 @brief Compute the number of bytes that would be needed to encode an
  enum field, including tag.Caller is responsible for converting the
  enum value to its numeric value.
 */
+ (jint)computeEnumSizeWithInt:(jint)fieldNumber
                       withInt:(jint)value;

/*!
 @brief Compute the number of bytes that would be needed to encode an enum field.
 Caller is responsible for converting the enum value to its numeric value.
 */
+ (jint)computeEnumSizeNoTagWithInt:(jint)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>fixed32</code> field, including tag.
 */
+ (jint)computeFixed32SizeWithInt:(jint)fieldNumber
                          withInt:(jint)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>fixed32</code> field.
 */
+ (jint)computeFixed32SizeNoTagWithInt:(jint)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>fixed64</code> field, including tag.
 */
+ (jint)computeFixed64SizeWithInt:(jint)fieldNumber
                         withLong:(jlong)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>fixed64</code> field.
 */
+ (jint)computeFixed64SizeNoTagWithLong:(jlong)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>float</code> field, including tag.
 */
+ (jint)computeFloatSizeWithInt:(jint)fieldNumber
                      withFloat:(jfloat)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>float</code> field, including tag.
 */
+ (jint)computeFloatSizeNoTagWithFloat:(jfloat)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>group</code> field, including tag.
 */
+ (jint)computeGroupSizeWithInt:(jint)fieldNumber
withComGoogleProtobufNanoMessageNano:(ComGoogleProtobufNanoMessageNano *)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>group</code> field.
 */
+ (jint)computeGroupSizeNoTagWithComGoogleProtobufNanoMessageNano:(ComGoogleProtobufNanoMessageNano *)value;

/*!
 @brief Compute the number of bytes that would be needed to encode an 
 <code>int32</code> field, including tag.
 */
+ (jint)computeInt32SizeWithInt:(jint)fieldNumber
                        withInt:(jint)value;

/*!
 @brief Compute the number of bytes that would be needed to encode an 
 <code>int32</code> field, including tag.
 */
+ (jint)computeInt32SizeNoTagWithInt:(jint)value;

/*!
 @brief Compute the number of bytes that would be needed to encode an 
 <code>int64</code> field, including tag.
 */
+ (jint)computeInt64SizeWithInt:(jint)fieldNumber
                       withLong:(jlong)value;

/*!
 @brief Compute the number of bytes that would be needed to encode an 
 <code>int64</code> field, including tag.
 */
+ (jint)computeInt64SizeNoTagWithLong:(jlong)value;

/*!
 @brief Compute the number of bytes that would be needed to encode an
  embedded message field, including tag.
 */
+ (jint)computeMessageSizeWithInt:(jint)fieldNumber
withComGoogleProtobufNanoMessageNano:(ComGoogleProtobufNanoMessageNano *)value;

/*!
 @brief Compute the number of bytes that would be needed to encode an embedded
  message field.
 */
+ (jint)computeMessageSizeNoTagWithComGoogleProtobufNanoMessageNano:(ComGoogleProtobufNanoMessageNano *)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a varint.
 <code>value</code> is treated as unsigned, so it won't be sign-extended if
  negative.
 */
+ (jint)computeRawVarint32SizeWithInt:(jint)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a varint.
 */
+ (jint)computeRawVarint64SizeWithLong:(jlong)value;

/*!
 @brief Compute the number of bytes that would be needed to encode an 
 <code>sfixed32</code> field, including tag.
 */
+ (jint)computeSFixed32SizeWithInt:(jint)fieldNumber
                           withInt:(jint)value;

/*!
 @brief Compute the number of bytes that would be needed to encode an 
 <code>sfixed32</code> field.
 */
+ (jint)computeSFixed32SizeNoTagWithInt:(jint)value;

/*!
 @brief Compute the number of bytes that would be needed to encode an 
 <code>sfixed64</code> field, including tag.
 */
+ (jint)computeSFixed64SizeWithInt:(jint)fieldNumber
                          withLong:(jlong)value;

/*!
 @brief Compute the number of bytes that would be needed to encode an 
 <code>sfixed64</code> field.
 */
+ (jint)computeSFixed64SizeNoTagWithLong:(jlong)value;

/*!
 @brief Compute the number of bytes that would be needed to encode an 
 <code>sint32</code> field, including tag.
 */
+ (jint)computeSInt32SizeWithInt:(jint)fieldNumber
                         withInt:(jint)value;

/*!
 @brief Compute the number of bytes that would be needed to encode an 
 <code>sint32</code> field.
 */
+ (jint)computeSInt32SizeNoTagWithInt:(jint)value;

/*!
 @brief Compute the number of bytes that would be needed to encode an 
 <code>sint64</code> field, including tag.
 */
+ (jint)computeSInt64SizeWithInt:(jint)fieldNumber
                        withLong:(jlong)value;

/*!
 @brief Compute the number of bytes that would be needed to encode an 
 <code>sint64</code> field.
 */
+ (jint)computeSInt64SizeNoTagWithLong:(jlong)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>string</code> field, including tag.
 */
+ (jint)computeStringSizeWithInt:(jint)fieldNumber
                    withNSString:(NSString *)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>string</code> field.
 */
+ (jint)computeStringSizeNoTagWithNSString:(NSString *)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a tag.
 */
+ (jint)computeTagSizeWithInt:(jint)fieldNumber;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>uint32</code> field, including tag.
 */
+ (jint)computeUInt32SizeWithInt:(jint)fieldNumber
                         withInt:(jint)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>uint32</code> field.
 */
+ (jint)computeUInt32SizeNoTagWithInt:(jint)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>uint64</code> field, including tag.
 */
+ (jint)computeUInt64SizeWithInt:(jint)fieldNumber
                        withLong:(jlong)value;

/*!
 @brief Compute the number of bytes that would be needed to encode a 
 <code>uint64</code> field, including tag.
 */
+ (jint)computeUInt64SizeNoTagWithLong:(jlong)value;

/*!
 @brief Encode a ZigZag-encoded 32-bit value.ZigZag encodes signed integers
  into values that can be efficiently encoded with varint.
 (Otherwise,
  negative values must be sign-extended to 64 bits to be varint encoded,
  thus always taking 10 bytes on the wire.)
 @param n A signed 32-bit integer.
 @return An unsigned 32-bit integer, stored in a signed int because
          Java has no explicit unsigned support.
 */
+ (jint)encodeZigZag32WithInt:(jint)n;

/*!
 @brief Encode a ZigZag-encoded 64-bit value.ZigZag encodes signed integers
  into values that can be efficiently encoded with varint.
 (Otherwise,
  negative values must be sign-extended to 64 bits to be varint encoded,
  thus always taking 10 bytes on the wire.)
 @param n A signed 64-bit integer.
 @return An unsigned 64-bit integer, stored in a signed int because
          Java has no explicit unsigned support.
 */
+ (jlong)encodeZigZag64WithLong:(jlong)n;

/*!
 @brief Create a new <code>CodedOutputStream</code> that writes directly to the given
  byte array.If more bytes are written than fit in the array, 
 <code>OutOfSpaceException</code> will be thrown.
 Writing directly to a flat
  array is faster than writing to an <code>OutputStream</code>.
 */
+ (ComGoogleProtobufNanoCodedOutputByteBufferNano *)newInstanceWithByteArray:(IOSByteArray *)flatArray OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Create a new <code>CodedOutputStream</code> that writes directly to the given
  byte array slice.If more bytes are written than fit in the slice, 
 <code>OutOfSpaceException</code> will be thrown.
 Writing directly to a flat
  array is faster than writing to an <code>OutputStream</code>.
 */
+ (ComGoogleProtobufNanoCodedOutputByteBufferNano *)newInstanceWithByteArray:(IOSByteArray *)flatArray
                                                                     withInt:(jint)offset
                                                                     withInt:(jint)length OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns the position within the internal buffer.
 */
- (jint)position;

/*!
 @brief Resets the position within the internal buffer to zero.
 - seealso: #position
 - seealso: #spaceLeft
 */
- (void)reset;

/*!
 @brief If writing to a flat array, return the space left in the array.
 Otherwise, throws <code>UnsupportedOperationException</code>.
 */
- (jint)spaceLeft;

/*!
 @brief Write a <code>bool</code> field, including tag, to the stream.
 */
- (void)writeBoolWithInt:(jint)fieldNumber
             withBoolean:(jboolean)value;

/*!
 @brief Write a <code>bool</code> field to the stream.
 */
- (void)writeBoolNoTagWithBoolean:(jboolean)value;

/*!
 @brief Write a <code>bytes</code> field, including tag, to the stream.
 */
- (void)writeBytesWithInt:(jint)fieldNumber
            withByteArray:(IOSByteArray *)value;

/*!
 @brief Write a <code>bytes</code> field to the stream.
 */
- (void)writeBytesNoTagWithByteArray:(IOSByteArray *)value;

/*!
 @brief Write a <code>double</code> field, including tag, to the stream.
 */
- (void)writeDoubleWithInt:(jint)fieldNumber
                withDouble:(jdouble)value;

/*!
 @brief Write a <code>double</code> field to the stream.
 */
- (void)writeDoubleNoTagWithDouble:(jdouble)value;

/*!
 @brief Write an enum field, including tag, to the stream.Caller is responsible
  for converting the enum value to its numeric value.
 */
- (void)writeEnumWithInt:(jint)fieldNumber
                 withInt:(jint)value;

/*!
 @brief Write an enum field to the stream.Caller is responsible
  for converting the enum value to its numeric value.
 */
- (void)writeEnumNoTagWithInt:(jint)value;

/*!
 @brief Write a <code>fixed32</code> field, including tag, to the stream.
 */
- (void)writeFixed32WithInt:(jint)fieldNumber
                    withInt:(jint)value;

/*!
 @brief Write a <code>fixed32</code> field to the stream.
 */
- (void)writeFixed32NoTagWithInt:(jint)value;

/*!
 @brief Write a <code>fixed64</code> field, including tag, to the stream.
 */
- (void)writeFixed64WithInt:(jint)fieldNumber
                   withLong:(jlong)value;

/*!
 @brief Write a <code>fixed64</code> field to the stream.
 */
- (void)writeFixed64NoTagWithLong:(jlong)value;

/*!
 @brief Write a <code>float</code> field, including tag, to the stream.
 */
- (void)writeFloatWithInt:(jint)fieldNumber
                withFloat:(jfloat)value;

/*!
 @brief Write a <code>float</code> field to the stream.
 */
- (void)writeFloatNoTagWithFloat:(jfloat)value;

/*!
 @brief Write a <code>group</code> field, including tag, to the stream.
 */
- (void)writeGroupWithInt:(jint)fieldNumber
withComGoogleProtobufNanoMessageNano:(ComGoogleProtobufNanoMessageNano *)value;

/*!
 @brief Write a <code>group</code> field to the stream.
 */
- (void)writeGroupNoTagWithComGoogleProtobufNanoMessageNano:(ComGoogleProtobufNanoMessageNano *)value;

/*!
 @brief Write an <code>int32</code> field, including tag, to the stream.
 */
- (void)writeInt32WithInt:(jint)fieldNumber
                  withInt:(jint)value;

/*!
 @brief Write an <code>int32</code> field to the stream.
 */
- (void)writeInt32NoTagWithInt:(jint)value;

/*!
 @brief Write an <code>int64</code> field, including tag, to the stream.
 */
- (void)writeInt64WithInt:(jint)fieldNumber
                 withLong:(jlong)value;

/*!
 @brief Write an <code>int64</code> field to the stream.
 */
- (void)writeInt64NoTagWithLong:(jlong)value;

/*!
 @brief Write an embedded message field, including tag, to the stream.
 */
- (void)writeMessageWithInt:(jint)fieldNumber
withComGoogleProtobufNanoMessageNano:(ComGoogleProtobufNanoMessageNano *)value;

/*!
 @brief Write an embedded message field to the stream.
 */
- (void)writeMessageNoTagWithComGoogleProtobufNanoMessageNano:(ComGoogleProtobufNanoMessageNano *)value;

/*!
 @brief Write a single byte.
 */
- (void)writeRawByteWithByte:(jbyte)value;

/*!
 @brief Write a single byte, represented by an integer value.
 */
- (void)writeRawByteWithInt:(jint)value;

/*!
 @brief Write an array of bytes.
 */
- (void)writeRawBytesWithByteArray:(IOSByteArray *)value;

/*!
 @brief Write part of an array of bytes.
 */
- (void)writeRawBytesWithByteArray:(IOSByteArray *)value
                           withInt:(jint)offset
                           withInt:(jint)length;

/*!
 @brief Write a little-endian 32-bit integer.
 */
- (void)writeRawLittleEndian32WithInt:(jint)value;

/*!
 @brief Write a little-endian 64-bit integer.
 */
- (void)writeRawLittleEndian64WithLong:(jlong)value;

/*!
 @brief Encode and write a varint.
 <code>value</code> is treated as
  unsigned, so it won't be sign-extended if negative.
 */
- (void)writeRawVarint32WithInt:(jint)value;

/*!
 @brief Encode and write a varint.
 */
- (void)writeRawVarint64WithLong:(jlong)value;

/*!
 @brief Write an <code>sfixed32</code> field, including tag, to the stream.
 */
- (void)writeSFixed32WithInt:(jint)fieldNumber
                     withInt:(jint)value;

/*!
 @brief Write an <code>sfixed32</code> field to the stream.
 */
- (void)writeSFixed32NoTagWithInt:(jint)value;

/*!
 @brief Write an <code>sfixed64</code> field, including tag, to the stream.
 */
- (void)writeSFixed64WithInt:(jint)fieldNumber
                    withLong:(jlong)value;

/*!
 @brief Write an <code>sfixed64</code> field to the stream.
 */
- (void)writeSFixed64NoTagWithLong:(jlong)value;

/*!
 @brief Write an <code>sint32</code> field, including tag, to the stream.
 */
- (void)writeSInt32WithInt:(jint)fieldNumber
                   withInt:(jint)value;

/*!
 @brief Write an <code>sint32</code> field to the stream.
 */
- (void)writeSInt32NoTagWithInt:(jint)value;

/*!
 @brief Write an <code>sint64</code> field, including tag, to the stream.
 */
- (void)writeSInt64WithInt:(jint)fieldNumber
                  withLong:(jlong)value;

/*!
 @brief Write an <code>sint64</code> field to the stream.
 */
- (void)writeSInt64NoTagWithLong:(jlong)value;

/*!
 @brief Write a <code>string</code> field, including tag, to the stream.
 */
- (void)writeStringWithInt:(jint)fieldNumber
              withNSString:(NSString *)value;

/*!
 @brief Write a <code>string</code> field to the stream.
 */
- (void)writeStringNoTagWithNSString:(NSString *)value;

/*!
 @brief Encode and write a tag.
 */
- (void)writeTagWithInt:(jint)fieldNumber
                withInt:(jint)wireType;

/*!
 @brief Write a <code>uint32</code> field, including tag, to the stream.
 */
- (void)writeUInt32WithInt:(jint)fieldNumber
                   withInt:(jint)value;

/*!
 @brief Write a <code>uint32</code> field to the stream.
 */
- (void)writeUInt32NoTagWithInt:(jint)value;

/*!
 @brief Write a <code>uint64</code> field, including tag, to the stream.
 */
- (void)writeUInt64WithInt:(jint)fieldNumber
                  withLong:(jlong)value;

/*!
 @brief Write a <code>uint64</code> field to the stream.
 */
- (void)writeUInt64NoTagWithLong:(jlong)value;

#pragma mark Package-Private

+ (jint)computeFieldSizeWithInt:(jint)number
                        withInt:(jint)type
                         withId:(id)object;

- (void)writeFieldWithInt:(jint)number
                  withInt:(jint)type
                   withId:(id)value;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleProtobufNanoCodedOutputByteBufferNano)

inline jint ComGoogleProtobufNanoCodedOutputByteBufferNano_get_LITTLE_ENDIAN_32_SIZE(void);
#define ComGoogleProtobufNanoCodedOutputByteBufferNano_LITTLE_ENDIAN_32_SIZE 4
J2OBJC_STATIC_FIELD_CONSTANT(ComGoogleProtobufNanoCodedOutputByteBufferNano, LITTLE_ENDIAN_32_SIZE, jint)

inline jint ComGoogleProtobufNanoCodedOutputByteBufferNano_get_LITTLE_ENDIAN_64_SIZE(void);
#define ComGoogleProtobufNanoCodedOutputByteBufferNano_LITTLE_ENDIAN_64_SIZE 8
J2OBJC_STATIC_FIELD_CONSTANT(ComGoogleProtobufNanoCodedOutputByteBufferNano, LITTLE_ENDIAN_64_SIZE, jint)

FOUNDATION_EXPORT ComGoogleProtobufNanoCodedOutputByteBufferNano *ComGoogleProtobufNanoCodedOutputByteBufferNano_newInstanceWithByteArray_(IOSByteArray *flatArray);

FOUNDATION_EXPORT ComGoogleProtobufNanoCodedOutputByteBufferNano *ComGoogleProtobufNanoCodedOutputByteBufferNano_newInstanceWithByteArray_withInt_withInt_(IOSByteArray *flatArray, jint offset, jint length);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeDoubleSizeWithInt_withDouble_(jint fieldNumber, jdouble value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeFloatSizeWithInt_withFloat_(jint fieldNumber, jfloat value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeUInt64SizeWithInt_withLong_(jint fieldNumber, jlong value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeInt64SizeWithInt_withLong_(jint fieldNumber, jlong value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeInt32SizeWithInt_withInt_(jint fieldNumber, jint value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeFixed64SizeWithInt_withLong_(jint fieldNumber, jlong value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeFixed32SizeWithInt_withInt_(jint fieldNumber, jint value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeBoolSizeWithInt_withBoolean_(jint fieldNumber, jboolean value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeStringSizeWithInt_withNSString_(jint fieldNumber, NSString *value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeGroupSizeWithInt_withComGoogleProtobufNanoMessageNano_(jint fieldNumber, ComGoogleProtobufNanoMessageNano *value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeMessageSizeWithInt_withComGoogleProtobufNanoMessageNano_(jint fieldNumber, ComGoogleProtobufNanoMessageNano *value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeBytesSizeWithInt_withByteArray_(jint fieldNumber, IOSByteArray *value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeUInt32SizeWithInt_withInt_(jint fieldNumber, jint value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeEnumSizeWithInt_withInt_(jint fieldNumber, jint value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeSFixed32SizeWithInt_withInt_(jint fieldNumber, jint value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeSFixed64SizeWithInt_withLong_(jint fieldNumber, jlong value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeSInt32SizeWithInt_withInt_(jint fieldNumber, jint value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeSInt64SizeWithInt_withLong_(jint fieldNumber, jlong value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeDoubleSizeNoTagWithDouble_(jdouble value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeFloatSizeNoTagWithFloat_(jfloat value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeUInt64SizeNoTagWithLong_(jlong value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeInt64SizeNoTagWithLong_(jlong value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeInt32SizeNoTagWithInt_(jint value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeFixed64SizeNoTagWithLong_(jlong value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeFixed32SizeNoTagWithInt_(jint value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeBoolSizeNoTagWithBoolean_(jboolean value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeStringSizeNoTagWithNSString_(NSString *value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeGroupSizeNoTagWithComGoogleProtobufNanoMessageNano_(ComGoogleProtobufNanoMessageNano *value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeMessageSizeNoTagWithComGoogleProtobufNanoMessageNano_(ComGoogleProtobufNanoMessageNano *value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeBytesSizeNoTagWithByteArray_(IOSByteArray *value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeUInt32SizeNoTagWithInt_(jint value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeEnumSizeNoTagWithInt_(jint value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeSFixed32SizeNoTagWithInt_(jint value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeSFixed64SizeNoTagWithLong_(jlong value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeSInt32SizeNoTagWithInt_(jint value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeSInt64SizeNoTagWithLong_(jlong value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeTagSizeWithInt_(jint fieldNumber);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeRawVarint32SizeWithInt_(jint value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeRawVarint64SizeWithLong_(jlong value);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_encodeZigZag32WithInt_(jint n);

FOUNDATION_EXPORT jlong ComGoogleProtobufNanoCodedOutputByteBufferNano_encodeZigZag64WithLong_(jlong n);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoCodedOutputByteBufferNano_computeFieldSizeWithInt_withInt_withId_(jint number, jint type, id object);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleProtobufNanoCodedOutputByteBufferNano)

#endif

#if !defined (ComGoogleProtobufNanoCodedOutputByteBufferNano_OutOfSpaceException_) && (INCLUDE_ALL_ComGoogleProtobufNanoCodedOutputByteBufferNano || defined(INCLUDE_ComGoogleProtobufNanoCodedOutputByteBufferNano_OutOfSpaceException))
#define ComGoogleProtobufNanoCodedOutputByteBufferNano_OutOfSpaceException_

#define RESTRICT_JavaIoIOException 1
#define INCLUDE_JavaIoIOException 1
#include "java/io/IOException.h"

@class JavaLangThrowable;

/*!
 @brief If you create a CodedOutputStream around a simple flat array, you must
  not attempt to write more bytes than the array has space.Otherwise,
  this exception will be thrown.
 */
@interface ComGoogleProtobufNanoCodedOutputByteBufferNano_OutOfSpaceException : JavaIoIOException

#pragma mark Package-Private

- (instancetype)initWithInt:(jint)position
                    withInt:(jint)limit;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

- (instancetype)initWithJavaLangThrowable:(JavaLangThrowable *)arg0 NS_UNAVAILABLE;

- (instancetype)initWithNSString:(NSString *)arg0 NS_UNAVAILABLE;

- (instancetype)initWithNSString:(NSString *)arg0
           withJavaLangThrowable:(JavaLangThrowable *)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleProtobufNanoCodedOutputByteBufferNano_OutOfSpaceException)

FOUNDATION_EXPORT void ComGoogleProtobufNanoCodedOutputByteBufferNano_OutOfSpaceException_initWithInt_withInt_(ComGoogleProtobufNanoCodedOutputByteBufferNano_OutOfSpaceException *self, jint position, jint limit);

FOUNDATION_EXPORT ComGoogleProtobufNanoCodedOutputByteBufferNano_OutOfSpaceException *new_ComGoogleProtobufNanoCodedOutputByteBufferNano_OutOfSpaceException_initWithInt_withInt_(jint position, jint limit) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleProtobufNanoCodedOutputByteBufferNano_OutOfSpaceException *create_ComGoogleProtobufNanoCodedOutputByteBufferNano_OutOfSpaceException_initWithInt_withInt_(jint position, jint limit);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleProtobufNanoCodedOutputByteBufferNano_OutOfSpaceException)

#endif

#pragma pop_macro("INCLUDE_ALL_ComGoogleProtobufNanoCodedOutputByteBufferNano")
