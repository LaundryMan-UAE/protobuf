//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/marcussmith/HambroPerks/hambroperks_org/protobuf/javanano/src/main/java/com/google/protobuf/nano/InternalNano.java
//

#ifndef _ComGoogleProtobufNanoInternalNano_H_
#define _ComGoogleProtobufNanoInternalNano_H_

#include "J2ObjC_header.h"

@class ComGoogleProtobufNanoCodedInputByteBufferNano;
@class ComGoogleProtobufNanoCodedOutputByteBufferNano;
@class ComGoogleProtobufNanoExtendableMessageNano;
@class IOSBooleanArray;
@class IOSByteArray;
@class IOSDoubleArray;
@class IOSFloatArray;
@class IOSIntArray;
@class IOSLongArray;
@class IOSObjectArray;
@class JavaNioCharsetCharset;
@protocol ComGoogleProtobufNanoMapFactories_MapFactory;
@protocol JavaUtilMap;

#define ComGoogleProtobufNanoInternalNano_TYPE_DOUBLE 1
#define ComGoogleProtobufNanoInternalNano_TYPE_FLOAT 2
#define ComGoogleProtobufNanoInternalNano_TYPE_INT64 3
#define ComGoogleProtobufNanoInternalNano_TYPE_UINT64 4
#define ComGoogleProtobufNanoInternalNano_TYPE_INT32 5
#define ComGoogleProtobufNanoInternalNano_TYPE_FIXED64 6
#define ComGoogleProtobufNanoInternalNano_TYPE_FIXED32 7
#define ComGoogleProtobufNanoInternalNano_TYPE_BOOL 8
#define ComGoogleProtobufNanoInternalNano_TYPE_STRING 9
#define ComGoogleProtobufNanoInternalNano_TYPE_GROUP 10
#define ComGoogleProtobufNanoInternalNano_TYPE_MESSAGE 11
#define ComGoogleProtobufNanoInternalNano_TYPE_BYTES 12
#define ComGoogleProtobufNanoInternalNano_TYPE_UINT32 13
#define ComGoogleProtobufNanoInternalNano_TYPE_ENUM 14
#define ComGoogleProtobufNanoInternalNano_TYPE_SFIXED32 15
#define ComGoogleProtobufNanoInternalNano_TYPE_SFIXED64 16
#define ComGoogleProtobufNanoInternalNano_TYPE_SINT32 17
#define ComGoogleProtobufNanoInternalNano_TYPE_SINT64 18

/*!
 @brief The classes contained within are used internally by the Protocol Buffer
 library and generated message implementations.
 They are public only because
 those generated messages do not reside in the <code>protobuf</code> package.
 Others should not use this class directly.
 @author kenton@@google.com (Kenton Varda)
 */
@interface ComGoogleProtobufNanoInternalNano : NSObject

#pragma mark Public

/*!
 @brief Helper called by generated code to construct default values for bytes
 fields.
 <p>
 This is a lot like <code>stringDefaultValue</code>, but for bytes fields.
 In this case we only need the second of the two hacks -- allowing us to
 embed raw bytes as a string literal with ISO-8859-1 encoding.
 */
+ (IOSByteArray *)bytesDefaultValueWithNSString:(NSString *)bytes;

+ (void)cloneUnknownFieldDataWithComGoogleProtobufNanoExtendableMessageNano:(ComGoogleProtobufNanoExtendableMessageNano *)original
                             withComGoogleProtobufNanoExtendableMessageNano:(ComGoogleProtobufNanoExtendableMessageNano *)cloned;

+ (jint)computeMapFieldSizeWithJavaUtilMap:(id<JavaUtilMap>)map
                                   withInt:(jint)number
                                   withInt:(jint)keyType
                                   withInt:(jint)valueType;

/*!
 @brief Helper function to convert a string into UTF-8 while turning the
 UnsupportedEncodingException to a RuntimeException.
 */
+ (IOSByteArray *)copyFromUtf8WithNSString:(NSString *)text OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Checks repeated boolean field equality; null-value and 0-length fields are
 considered equal.
 */
+ (jboolean)equalsWithBooleanArray:(IOSBooleanArray *)field1
                  withBooleanArray:(IOSBooleanArray *)field2;

/*!
 @brief Checks repeated bytes field equality.
 Only non-null elements are tested.
 Returns true if the two fields have the same sequence of non-null
 elements. Null-value fields and fields of any length with only null
 elements are considered equal.
 */
+ (jboolean)equalsWithByteArray2:(IOSObjectArray *)field1
                  withByteArray2:(IOSObjectArray *)field2;

/*!
 @brief Checks repeated double field equality; null-value and 0-length fields are
 considered equal.
 */
+ (jboolean)equalsWithDoubleArray:(IOSDoubleArray *)field1
                  withDoubleArray:(IOSDoubleArray *)field2;

/*!
 @brief Checks repeated float field equality; null-value and 0-length fields are
 considered equal.
 */
+ (jboolean)equalsWithFloatArray:(IOSFloatArray *)field1
                  withFloatArray:(IOSFloatArray *)field2;

/*!
 @brief Checks repeated int field equality; null-value and 0-length fields are
 considered equal.
 */
+ (jboolean)equalsWithIntArray:(IOSIntArray *)field1
                  withIntArray:(IOSIntArray *)field2;

/*!
 @brief Checks repeated long field equality; null-value and 0-length fields are
 considered equal.
 */
+ (jboolean)equalsWithLongArray:(IOSLongArray *)field1
                  withLongArray:(IOSLongArray *)field2;

/*!
 @brief Checks whether two <code>Map</code> are equal.
 We don't use the default equals
 method of <code>Map</code> because it compares by identity not by content for
 byte arrays.
 */
+ (jboolean)equalsWithJavaUtilMap:(id<JavaUtilMap>)a
                  withJavaUtilMap:(id<JavaUtilMap>)b;

/*!
 @brief Checks repeated string/message field equality.
 Only non-null elements are
 tested. Returns true if the two fields have the same sequence of non-null
 elements. Null-value fields and fields of any length with only null
 elements are considered equal.
 */
+ (jboolean)equalsWithNSObjectArray:(IOSObjectArray *)field1
                  withNSObjectArray:(IOSObjectArray *)field2;

/*!
 @brief Computes the hash code of a repeated boolean field.
 Null-value and 0-length
 fields have the same hash code.
 */
+ (jint)hashCodeWithBooleanArray:(IOSBooleanArray *)field;

/*!
 @brief Computes the hash code of a repeated bytes field.
 Only the sequence of all
 non-null elements are used in the computation. Null-value fields and fields
 of any length with only null elements have the same hash code.
 */
+ (jint)hashCodeWithByteArray2:(IOSObjectArray *)field;

/*!
 @brief Computes the hash code of a repeated double field.
 Null-value and 0-length
 fields have the same hash code.
 */
+ (jint)hashCodeWithDoubleArray:(IOSDoubleArray *)field;

/*!
 @brief Computes the hash code of a repeated float field.
 Null-value and 0-length
 fields have the same hash code.
 */
+ (jint)hashCodeWithFloatArray:(IOSFloatArray *)field;

/*!
 @brief Computes the hash code of a repeated int field.
 Null-value and 0-length
 fields have the same hash code.
 */
+ (jint)hashCodeWithIntArray:(IOSIntArray *)field;

/*!
 @brief Computes the hash code of a repeated long field.
 Null-value and 0-length
 fields have the same hash code.
 */
+ (jint)hashCodeWithLongArray:(IOSLongArray *)field;

+ (jint)hashCodeWithJavaUtilMap:(id<JavaUtilMap>)map;

/*!
 @brief Computes the hash code of a repeated string/message field.
 Only the
 sequence of all non-null elements are used in the computation. Null-value
 fields and fields of any length with only null elements have the same hash
 code.
 */
+ (jint)hashCodeWithNSObjectArray:(IOSObjectArray *)field;

/*!
 @brief Merges the map entry into the map field.
 Note this is only supposed to
 be called by generated messages.
 @param map the map field; may be null, in which case a map will be
 instantiated using the <code>MapFactories.MapFactory</code>
 @param input the input byte buffer
 @param keyType key type, as defined in InternalNano.TYPE_
 @param valueType value type, as defined in InternalNano.TYPE_
 @param value an new instance of the value, if the value is a TYPE_MESSAGE;
 otherwise this parameter can be null and will be ignored.
 @param keyTag wire tag for the key
 @param valueTag wire tag for the value
 @return the map field
 @throws IOException
 */
+ (id<JavaUtilMap>)mergeMapEntryWithComGoogleProtobufNanoCodedInputByteBufferNano:(ComGoogleProtobufNanoCodedInputByteBufferNano *)input
                                                                  withJavaUtilMap:(id<JavaUtilMap>)map
                                 withComGoogleProtobufNanoMapFactories_MapFactory:(id<ComGoogleProtobufNanoMapFactories_MapFactory>)mapFactory
                                                                          withInt:(jint)keyType
                                                                          withInt:(jint)valueType
                                                                           withId:(id)value
                                                                          withInt:(jint)keyTag
                                                                          withInt:(jint)valueTag;

+ (void)serializeMapFieldWithComGoogleProtobufNanoCodedOutputByteBufferNano:(ComGoogleProtobufNanoCodedOutputByteBufferNano *)output
                                                            withJavaUtilMap:(id<JavaUtilMap>)map
                                                                    withInt:(jint)number
                                                                    withInt:(jint)keyType
                                                                    withInt:(jint)valueType;

/*!
 @brief Helper called by generated code to construct default values for string
 fields.
 <p>
 The protocol compiler does not actually contain a UTF-8 decoder -- it
 just pushes UTF-8-encoded text around without touching it.  The one place
 where this presents a problem is when generating Java string literals.
 Unicode characters in the string literal would normally need to be encoded
 using a Unicode escape sequence, which would require decoding them.
 To get around this, protoc instead embeds the UTF-8 bytes into the
 generated code and leaves it to the runtime library to decode them.
 <p>
 It gets worse, though.  If protoc just generated a byte array, like:
 new byte[] {0x12, 0x34, 0x56, 0x78}
 Java actually generates *code* which allocates an array and then fills
 in each value.  This is much less efficient than just embedding the bytes
 directly into the bytecode.  To get around this, we need another
 work-around.  String literals are embedded directly, so protoc actually
 generates a string literal corresponding to the bytes.  The easiest way
 to do this is to use the ISO-8859-1 character set, which corresponds to
 the first 256 characters of the Unicode range.  Protoc can then use
 good old CEscape to generate the string.
 <p>
 So we have a string literal which represents a set of bytes which
 represents another string.  This function -- stringDefaultValue --
 converts from the generated string to the string we actually want.  The
 generated code calls this automatically.
 */
+ (NSString *)stringDefaultValueWithNSString:(NSString *)bytes;

@end

J2OBJC_STATIC_INIT(ComGoogleProtobufNanoInternalNano)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_DOUBLE, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_FLOAT, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_INT64, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_UINT64, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_INT32, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_FIXED64, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_FIXED32, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_BOOL, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_STRING, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_GROUP, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_MESSAGE, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_BYTES, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_UINT32, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_ENUM, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_SFIXED32, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_SFIXED64, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_SINT32, jint)

J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, TYPE_SINT64, jint)

FOUNDATION_EXPORT JavaNioCharsetCharset *ComGoogleProtobufNanoInternalNano_UTF_8_;
J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, UTF_8_, JavaNioCharsetCharset *)

FOUNDATION_EXPORT JavaNioCharsetCharset *ComGoogleProtobufNanoInternalNano_ISO_8859_1_;
J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, ISO_8859_1_, JavaNioCharsetCharset *)

FOUNDATION_EXPORT id ComGoogleProtobufNanoInternalNano_LAZY_INIT_LOCK_;
J2OBJC_STATIC_FIELD_GETTER(ComGoogleProtobufNanoInternalNano, LAZY_INIT_LOCK_, id)

FOUNDATION_EXPORT NSString *ComGoogleProtobufNanoInternalNano_stringDefaultValueWithNSString_(NSString *bytes);

FOUNDATION_EXPORT IOSByteArray *ComGoogleProtobufNanoInternalNano_bytesDefaultValueWithNSString_(NSString *bytes);

FOUNDATION_EXPORT IOSByteArray *ComGoogleProtobufNanoInternalNano_copyFromUtf8WithNSString_(NSString *text);

FOUNDATION_EXPORT jboolean ComGoogleProtobufNanoInternalNano_equalsWithIntArray_withIntArray_(IOSIntArray *field1, IOSIntArray *field2);

FOUNDATION_EXPORT jboolean ComGoogleProtobufNanoInternalNano_equalsWithLongArray_withLongArray_(IOSLongArray *field1, IOSLongArray *field2);

FOUNDATION_EXPORT jboolean ComGoogleProtobufNanoInternalNano_equalsWithFloatArray_withFloatArray_(IOSFloatArray *field1, IOSFloatArray *field2);

FOUNDATION_EXPORT jboolean ComGoogleProtobufNanoInternalNano_equalsWithDoubleArray_withDoubleArray_(IOSDoubleArray *field1, IOSDoubleArray *field2);

FOUNDATION_EXPORT jboolean ComGoogleProtobufNanoInternalNano_equalsWithBooleanArray_withBooleanArray_(IOSBooleanArray *field1, IOSBooleanArray *field2);

FOUNDATION_EXPORT jboolean ComGoogleProtobufNanoInternalNano_equalsWithByteArray2_withByteArray2_(IOSObjectArray *field1, IOSObjectArray *field2);

FOUNDATION_EXPORT jboolean ComGoogleProtobufNanoInternalNano_equalsWithNSObjectArray_withNSObjectArray_(IOSObjectArray *field1, IOSObjectArray *field2);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoInternalNano_hashCodeWithIntArray_(IOSIntArray *field);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoInternalNano_hashCodeWithLongArray_(IOSLongArray *field);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoInternalNano_hashCodeWithFloatArray_(IOSFloatArray *field);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoInternalNano_hashCodeWithDoubleArray_(IOSDoubleArray *field);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoInternalNano_hashCodeWithBooleanArray_(IOSBooleanArray *field);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoInternalNano_hashCodeWithByteArray2_(IOSObjectArray *field);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoInternalNano_hashCodeWithNSObjectArray_(IOSObjectArray *field);

FOUNDATION_EXPORT id<JavaUtilMap> ComGoogleProtobufNanoInternalNano_mergeMapEntryWithComGoogleProtobufNanoCodedInputByteBufferNano_withJavaUtilMap_withComGoogleProtobufNanoMapFactories_MapFactory_withInt_withInt_withId_withInt_withInt_(ComGoogleProtobufNanoCodedInputByteBufferNano *input, id<JavaUtilMap> map, id<ComGoogleProtobufNanoMapFactories_MapFactory> mapFactory, jint keyType, jint valueType, id value, jint keyTag, jint valueTag);

FOUNDATION_EXPORT void ComGoogleProtobufNanoInternalNano_serializeMapFieldWithComGoogleProtobufNanoCodedOutputByteBufferNano_withJavaUtilMap_withInt_withInt_withInt_(ComGoogleProtobufNanoCodedOutputByteBufferNano *output, id<JavaUtilMap> map, jint number, jint keyType, jint valueType);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoInternalNano_computeMapFieldSizeWithJavaUtilMap_withInt_withInt_withInt_(id<JavaUtilMap> map, jint number, jint keyType, jint valueType);

FOUNDATION_EXPORT jboolean ComGoogleProtobufNanoInternalNano_equalsWithJavaUtilMap_withJavaUtilMap_(id<JavaUtilMap> a, id<JavaUtilMap> b);

FOUNDATION_EXPORT jint ComGoogleProtobufNanoInternalNano_hashCodeWithJavaUtilMap_(id<JavaUtilMap> map);

FOUNDATION_EXPORT void ComGoogleProtobufNanoInternalNano_cloneUnknownFieldDataWithComGoogleProtobufNanoExtendableMessageNano_withComGoogleProtobufNanoExtendableMessageNano_(ComGoogleProtobufNanoExtendableMessageNano *original, ComGoogleProtobufNanoExtendableMessageNano *cloned);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleProtobufNanoInternalNano)

#endif // _ComGoogleProtobufNanoInternalNano_H_
